##  (C) 2025 Frank Lübeck, Lehrstuhl für Algebra und Zahlentheorie, RWTH Aachen
##  
##  This file provides 'PowerMapsOfAllClasses' for a group G.
##  It returns a list of lists.
##  If x is in ConjugacyClasses(G)[i] of order k then the i-th entry
##  of the result is of length k and the j-th entry is the number of
##  the class of x^(j-1).
##  
##  This implementation tries to minimize the number of conjugacy tests. 
##  
##  There are also a number of applications:
##     MaximalCyclics(G)  indices of classes whose representatives generate
##     the maximal cyclic subgroups up to conjugacy.
##  
##     RationalClassSets(G) subsets of indices of conjugacy classes of G
##     whose representatives generate conjugate cyclic subgroups.
##  
##     InduceAllFromCyclicSubgroup(G, i) all induced characters for irreducibles
##     of cyclic subgroups generated by elements in class i.
##  
##     InducedFromAllMaximalCyclicSubgroups(G) induced characters from all
##     maximal cyclic subgroups of G.
##  
##     PowerMapCharacters(G, n)
##     SmallPowerMapCharacters(G)  a list of generalized characters of G
##     associated to the map g -> g^n on G.
##  

InstallMethod(PowerMapsOfAllClasses, ["IsGroup"], function(G)
  local cls, reps, ords, sords, perm, res, o, ps, gens, s, orb, trans, stab,
        ostab, j, k, new, pos, x, y, xo, map, mapk, i, g, l, e, p;
  cls := ConjugacyClasses(G);
  reps := List(cls, Representative);
  ords := List(reps, Order);
  sords := ShallowCopy(ords);
  perm := [1..Length(cls)];
  SortParallel(sords, perm);

  res := [];
  # we start with small orders
  for i in perm do
    if not IsBound(res[i]) then
      o := ords[i];
      if o = 1 then
        res[i] := [i];
        continue;
      fi;
      ps := Set(Factors(o));

      # first the rational class of reps[i] 
      # straight forward orbit-stabilizer algorithm for the group of units mod o
      gens := Flat(GeneratorsPrimeResidues(o).generators);
      s := Phi(o);
      orb := [i];
      trans := [1];
      stab := BlistList([1..o], [1]);
      ostab := 1;
      j := 1;
      while j <= Length(orb) do
        k := orb[j];
        for g in gens do
          if ForAll([1..j], r-> stab[(trans[j]*g/trans[r]) mod o] = false) then
            new := PositionConjugacyClass(G, reps[k]^g);
            pos := Position(orb, new);
            if pos = fail then
              # new class in orbit
              Add(orb, new);
              Add(trans, (trans[j]*g) mod o);
            else
              # new element in stabilizer
              x := (trans[j]*g/trans[pos]) mod o;
              y := x;
              xo := 1;
              while not stab[y] do
                y := (y*x) mod o;
                xo := xo+1;
              od;
              for l in [1..o] do
                if stab[l] then
                  y := (l*x) mod o;
                  for e in [1..xo-1] do
                    stab[y] := true;
                    y := (y*x) mod o;
                  od;
                fi;
              od;
              ostab := ostab*xo;
            fi;
            if ostab*Length(orb) = s then
              break;
            fi;
          fi;
        od;
        if ostab*Length(orb) = s then
          j := o;
        else
          j := j+1;
        fi;
      od;
      map := [];
      map[o] := perm[1];
      for j in [1..o] do
        if stab[j] then
          for k in [1..Length(orb)] do
            map[(j*trans[k]) mod o] := orb[k];
          od;
        fi;
      od;

      # the rest we get from smaller order classes (already done)
      for p in ps do
        k := o/p;
        pos := PositionConjugacyClass(G, reps[i]^p);
        mapk := res[pos];
        for j in [1..k-1] do
          map[(p*j) mod o] := mapk[j];
        od;
      od;
      res[i] := map;

      # and we get the maps for the other classes in the same rational class
      for j in [2..Length(orb)] do
        mapk := [];
        for k in [1..o-1] do
          mapk[k] := map[(trans[j]*k) mod o];
        od;
        mapk[o] := perm[1];
        res[orb[j]] := mapk;
      od;
    fi;
  od;

  # so far we have in res[i][k] the class of reps[i]^k,
  # now we shift it to reps[i]^(k-1), so that the trivial class comes first
  res := List(res, a-> Concatenation([a[Length(a)]],a{[1..Length(a)-1]}));

  return res;
end);


# all induced characters of linear characters of the cyclic group
# generated by an element in class i
BindGlobal("InduceAllFromCyclicSubgroup", function(G, i)
  local ct, cls, pm, cen, o, I, chorb, null, res, k, ch, l, j, a;
  ct := CharacterTable(G);
  cls := ConjugacyClasses(G);
  pm := PowerMapsOfAllClasses(G)[i];
  cen := [];
  for j in pm do
    cen[j] := Size(G)/Size(cls[j]);
  od;
  o := Length(pm);
  I := Positions(pm, i)-1;

  # some linear characters obviously yield the same induced character
  chorb := Set(List([0..o-1], j-> Set((j*I) mod o)));

  null := 0*[1..Length(cls)];
  res := [];
  for a in chorb do
    k := a[1];
    ch := ShallowCopy(null);
    for j in [0..o-1] do
      l := pm[j+1];
      ch[l] := ch[l] + cen[l]/o * E(o)^(j*k);
    od;
    Add(res, Character(ct, ch));
  od;
  return res;
end);

# returns list l of indices such that reps of classes i, i in l,
# generate representatives of maximal cyclic subgroups
InstallMethod(MaximalCyclics, ["IsGroup"], function(G)
  local pms, ords, k, l, bl, res, i, j, m;
  pms := PowerMapsOfAllClasses(G);
  ords := List(pms, Length);
  k := Length(pms);
  l := [1..k];
  SortParallel(ords, l);
  bl := BlistList([1..k], []);
  res := [];
  for j in [k,k-1..1] do
    i := l[j];
    if not bl[i] then
      Add(res, i);
      for m in pms[i] do
        bl[m] := true;
      od;
    fi;
  od;
  return res;
end);

# induced characters of all irreducibles of maximal cyclic subgroups
# (these always span the space of all class functions)
BindGlobal("InducedFromAllMaximalCyclicSubgroups", function(G)
  local res, i;
  res := [];
  for i in MaximalCyclics(G) do
    Append(res, InduceAllFromCyclicSubgroup(G, i));
  od;
  return res;
end);

DeclareAttribute("RationalClassSets", IsGroup);
InstallMethod(RationalClassSets, ["IsGroup"], function(G)
  local pms, ords, k, bl, res, s, i, j;
  pms := PowerMapsOfAllClasses(G);
  ords := List(pms, Length);
  k := Length(pms);
  bl := BlistList([1..k], []);
  res := [];
  for i in [1..k] do
    if not bl[i] then
      s := [];
      for j in [1..Length(pms[i])] do
        if Gcd(ords[i], j-1) = 1 then
          Add(s, pms[i][j]);
          bl[pms[i][j]] := true;
        fi;
      od;
      Add(res, Set(s));
    fi;
  od;
  return res;
end);

##  Here we use a theorem of Frobenius as explained in 
##  Serre, Linear representations of finite groups, Section 11.2
##  
##  For a positive integer n and a rational class C of the group G the class
##  function with value |G|/gcd(|G|,n) on elements x with x^n in  C and 0
##  anywhere else is a generalized character (Theorem 23 in loc.cit. is finer,
##  but we sum over all classes in a rational class to get rational
##  integer coefficients).
##  
##  This function returns for G and n the just described class functions for all
##  classes with non-empty preimages.
##  
BindGlobal("PowerMapCharacters", function(G, n)
  local t, pm, ords, k, sz, l, s, c, rc, res, ch, pos, a;
  t := CharacterTable(G);
  pm := PowerMapsOfAllClasses(G);
  ords := List(pm, Length);
  k := Length(pm);
  sz := Size(G);
  l := List([1..k], i-> pm[i][(n mod ords[i])+1]);
  s := Set(l);
  c := sz/Gcd(sz, n);
  rc := RationalClassSets(G);
  res := [];
  for a in rc do
    if a[1] in s then
      ch := 0*[1..k];
      pos := Concatenation(List(a, i-> Positions(l, i)));
      ch{pos} := ch{pos}+c;
      Add(res, Character(t, ch));
    fi;
  od;
  return res;
end);

##  Here we use the previous function for some large divisors of |G| (that is
##  small non-zero values) associated to the element orders in G.
BindGlobal("SmallPowerMapCharacters", function(G)
  local pm, orders, sz, e, fac, ns, o, f, n, l, ps, res, pos, i, a;
  pm := PowerMapsOfAllClasses(G);
  orders := Set(List(pm, Length));
  sz := Size(G);
  e := Lcm(orders);
  fac := Collected(Factors(sz));
  ns := [];
  for i in [2..Length(orders)] do
    o := orders[i];
    f := Set(Factors(o));
    n := Product(List(Filtered(fac, a-> not a[1] in f), b-> b[1]^b[2]));
    Add(ns, n);
    while Gcd(sz, n*o) mod e <> 0 do
      n := n*o;
      Add(ns, n);
    od;
  od;
  l := Concatenation(List(Set(ns), n-> PowerMapCharacters(G, n)));
  # Some functions can have the same pattern of zero entries, we
  # only keep those with minimal non-zero values.
  ps := List(l, a-> Positions(a,0));
  res := [];
  for a in Set(ps) do
    pos := Positions(ps, a);
    Add(res, Minimum(l{pos}));
  od;
  return res;
end);


