<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="InduceReduce">

<TitlePage>
	<Title>The <Package>InduceReduce</Package> Package</Title>
	<Version>Version 1.0</Version>
	<Author>Jonathan Gruber
		<Email>gruber@mathematik.uni-kl.de</Email>
	</Author>

	    <Copyright> 
    <Index>License</Index>
    &copyright; 2018 by Jonathan Gruber<P/>
    The <Package>InduceReduce</Package> package is free software; 
    you can redistribute it and/or modify it under the terms of the 
    <URL Text="GNU General Public License">http://www.fsf.org/licenses/gpl.html</URL> 
    as published by the Free Software Foundation; either version 3 of the License, 
    or (at your option) any later version.
</Copyright>
<Acknowledgements>
    I would like to thank Gunter Malle both for teaching me the theory behind the algorithm which is implemented in the program and for suggesting to make it a &GAP; package.
</Acknowledgements>
</TitlePage>

<TableOfContents/>

<Body>
	<Chapter> <Heading>The <Package>InduceReduce</Package> package</Heading>
		<Section Label="sec:theory"> <Heading>Theory</Heading>
			The <Package>InduceReduce</Package> provides a function for 	computing the table of ordinary irreducible characters of a finite group <M>G</M> using an algorithm based on Brauer's theorem on induced characters (see the <URL><Link>https://en.wikipedia.org/wiki/Brauer%27s_theorem_on_induced_characters</Link> <LinkText>Wikipedia</LinkText></URL> article), which has been described by W. Unger in <Cite Key="Unger"/>. By Brauer's theorem, the ring <M> \mathbb{Z} \mathop{Irr}(G)</M> of generalized characters of <M>G</M> is generated by the induced characters <M>\mathop{Ind}_H^G(\lambda)</M>, where <M>H</M> runs over all elementary subgroups of <M>G</M> and <M>\lambda</M> runs over all irreducible characters of <M>H</M>. The algorithm runs over suitably chosen elementary subgroups of <M>G</M>, computes their irreducible characters and induces them to <M>G</M>. In the resulting lattice of genralized characters, it searches for an orthonormal basis by means of LLL lattice reduction. Once an orthonormal basis of size equal to the number of conjugacy classes of <M>G</M> is found, it is clear from character theory that the elements of this basis are up to sign the irreducible characters of <M>G</M>.
		</Section>

		<Section> <Heading>Program</Heading>
			<ManSection>
				<Func Name="CharacterTableUnger" Arg="G"/>
				<Description>
					This  function computes the character table of a finite group using Unger's algorithm.
					<Example>
						gap> G:=AlternatingGroup(6);;
						gap> CharacterTableUnger(G);
						CharacterTable( Alt( [ 1 .. 6 ] ) )
					</Example>
				</Description>
			</ManSection>
			
			<ManSection>
				<InfoClass Name="InfoCTUnger" />
				<Description>
					The infoclass <Code>InfoCTUnger</Code> makes the function <Code>CharacterTableUnger</Code> display information about the current state of the computation, which may be useful for computations with large groups. If <Code>InfoCTUnger</Code> is set to <Code>1</Code> then the function first displays the number of conjugaxcy classes of <Arg>G</Arg> and then shows for any elementary subgroup <Math>E=ZP</Math> whose characters are induced to <Arg>G</Arg> the order of <Math>Z</Math>, the order of <Math>P</Math> and the number of conjugacy classes of <Math>E</Math>. If <Code>InfoCTUnger</Code> is set to <Code>2</Code> then it additionally displays the orders of the conjugacy. Moreover, it shows after each LLL reduction the total number of irreducible characters found so far, the dimension of the character lattice and the determinant of the Gram matrix.
					<Example>
						gap> G:=AlternatingGroup(6);;
						gap> SetInfoLevel(InfoCTUnger,1);
						gap> CharacterTableUnger(G);
						#I  Induce/Restrict: group with 7 conjugacy classes.
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						CharacterTable( Alt( [ 1 .. 6 ] ) )

						gap> SetInfoLevel(InfoCTUnger,2);
						gap> CharacterTableUnger(G);
						#I  Induce/Restrict: group with 7 conjugacy classes.
						#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
						#I  Reduce: |Irr| = 1, dim = 4, det(G) = 43
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
						#I  Reduce: |Irr| = 1, dim = 6, det(G) = 8
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Reduce: |Irr| = 2, dim = 7, det(G) = 4
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Reduce: |Irr| = 7
						CharacterTable( Alt( [ 1 .. 6 ] ) )
					</Example>
				</Description>
			</ManSection>

			<ManSection>
				<Var Name="DOCYCLICFIRST" Label="cycliclast" />
				<Var Name="DOCYCLICLAST" Label="cycliclast" />
				<Description>
					A boolean variable telling the function <Code>CharacterTableUnger</Code> to first induce all irreducible characters of the cyclic subgroups and then proceed to do the same for the non-cyclic elementary subgroups. <Code>DOCYCLICLAST</Code> does the opposite, that is, it tells <Code>CharacterTableUnger</Code> to first induce the characters of the non-cyclic elementary subgroups and then proceed to induce the characters of the cyclic subgroups. Note that even when <Code>DOCYCLICLAST</Code> is <Code>true</Code>, it may happen that some cyclic group are used by the algorithm earlier than some non-cyclic elementary subgroups, but only when the group <Math>P</Math> in <Math>E=ZP</Math> is cyclic.
					<Example>
						gap> SetInfoLevel(InfoCTUnger,2);
						gap> G:=AlternatingGroup(6);;
						gap> DOCYCLICFIRST:=true;;
						gap> CharacterTableUnger(G);
						#I  Induce/Restrict: group with 7 conjugacy classes.
						#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
						#I  Induce: from cyclic subgroups
						#I  Reduce: |Irr| = 7
						CharacterTable( Alt( [ 1 .. 6 ] ) )

						gap> DOCYCLICFIRST:=false;;
						gap> DOCYCLICLAST:=true;;
						gap> CharacterTableUnger(G);
						#I  Induce/Restrict: group with 7 conjugacy classes.
						#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 8, 5 ]
						#I  Reduce: |Irr| = 1, dim = 4, det(G) = 28
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 5, 5 ]
						#I  Reduce: |Irr| = 5, dim = 6, det(G) = 2
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 9, 9 ]
						#I  Reduce: |Irr| = 7
						CharacterTable( Alt( [ 1 .. 6 ] ) )
					</Example>
				</Description>
			</ManSection>
			<ManSection>
				<Var Name="LLLOFFSET" />
				<Description>
					An integer variable telling the function <Code>CharacterTableUnger</Code> to not apply LLL reduction to the Gram matrix of the character Lattice each time after the characters of some elementary subgroup have been induced. Instead, the first reduction is carried out as soon as the characters of the <Code>LLLOFFSET</Code>-th elementary subgroup have been induced.
					<Example>
						gap> SetInfoLevel(InfoCTUnger,2);
						gap> G:=AlternatingGroup(6);;
						gap> LLLOFFSET:=3;;
						gap> CharacterTableUnger(G);
						#I  Induce/Restrict: group with 7 conjugacy classes.
						#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Reduce: |Irr| = 2, dim = 7, det(G) = 4
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Reduce: |Irr| = 7
						CharacterTable( Alt( [ 1 .. 6 ] ) )
					</Example>
				</Description>
			</ManSection>
			<ManSection>
				<Var Name="DELTA" />
				<Description>
					A float variable which specifies the parameter <M>\delta</M> for the LLL reduction, where <M>0.25&lt;\delta\leq 1.0</M>. The default value of <Code>DELTA</Code> is <Code>1.0</Code>.
					<Example>
						gap> SetInfoLevel(InfoCTUnger,2);
						gap> G:=AlternatingGroup(6);;
						gap> DELTA:=0.3;;
						gap> CharacterTableUnger(G);
						#I  Induce/Restrict: group with 7 conjugacy classes.
						#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
						#I  Reduce: |Irr| = 1, dim = 4, det(G) = 43
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
						#I  Reduce: |Irr| = 1, dim = 6, det(G) = 8
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Reduce: |Irr| = 2, dim = 7, det(G) = 4
						#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
						#I  Reduce: |Irr| = 7
						CharacterTable( Alt( [ 1 .. 6 ] ) )

					</Example>
				</Description>
			</ManSection>
		</Section>
	</Chapter>

	<Chapter> <Heading>Installing and Loading the <Package>IndeceReduce</Package> Package</Heading>
		<Section Label="sec:installing"> <Heading>Installing the package</Heading>
			InduceReduce does not use external binaries and, therefore, works without restrictions on the type of the operating system.<Br/>

			There are two ways of installing a &GAP; package. If you have permission to add files to the installation of &GAP; on your system you may install <Package>InduceReduce</Package> into the `pkg' subdirectory of the &GAP; installation tree. Otherwise you may install <Package>InduceReduce</Package> in a private `pkg' directory (for details see <URL> <Link>https://www.gap-system.org/Manuals/doc/ref/chap76.html#X82473E4B8756C6CD</Link> <LinkText>76.1 Installing a &GAP; Package</LinkText> </URL> and <URL> <Link>https://www.gap-system.org/Manuals/doc/ref/chap9.html#X7A4973627A5DB27D</Link> <LinkText>9.2 &GAP; Root Directories</LinkText> </URL> in the reference manual).
		</Section>

		<Section> <Heading>Loading the package</Heading>
			Once you have installed the package as described in the previous section, you can load it in a &GAP; session using the command <Code>LoadPackage("InduceReduce")</Code>.
		</Section>
	</Chapter>
</Body>

<Bibliography Databases="InduceReduce" />
<TheIndex/>

</Book>
